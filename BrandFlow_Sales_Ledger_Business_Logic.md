# 📊 BrandFlow - 영업 데이터 기반 원장 정리 시스템

## 🎯 핵심 비즈니스 로직: 영업직 → 원장 → 정산

### 📋 전체 데이터 흐름
```
영업직 매출 등록 → 관리자 승인 → 원장 반영 → 인센티브 계산 → 재무 분석 → 정산 완료
```

---

## 💰 매출 데이터 등록 시스템

### 1. 영업직(직원) 매출 등록 프로세스
```javascript
// 매출 등록 시 자동 계산 로직
const handleCreateSale = async (saleData) => {
  // 1. 상품 정보 기반 자동 계산
  const product = await getProductById(saleData.productId);
  
  const calculatedData = {
    // 기본 정보
    saleNumber: generateSaleNumber(), // 매출번호 자동 생성
    productId: saleData.productId,
    quantity: saleData.quantity,
    
    // 금액 계산
    actualCostPrice: saleData.actualCostPrice || product.costPrice,
    actualSellingPrice: saleData.actualSellingPrice || product.sellingPrice,
    totalSales: saleData.actualSellingPrice * saleData.quantity,
    
    // 마진 계산
    marginAmount: (saleData.actualSellingPrice - saleData.actualCostPrice) * saleData.quantity,
    marginRate: ((saleData.actualSellingPrice - saleData.actualCostPrice) / saleData.actualCostPrice * 100).toFixed(2),
    
    // 인센티브 계산 (담당 직원 기준)
    incentiveAmount: calculateIncentiveAmount(saleData, employee),
    
    // 등록 정보
    salesPersonId: loggedInUser.id,
    salesPersonName: loggedInUser.name,
    status: '등록', // 초기 상태
    saleDate: saleData.saleDate || new Date().toISOString(),
    
    // 클라이언트 정보
    clientName: saleData.clientName,
    clientContact: saleData.clientContact,
    clientEmail: saleData.clientEmail,
    
    // 계약 정보
    contractStartDate: saleData.contractStartDate,
    contractEndDate: saleData.contractEndDate,
    
    // 연관 데이터
    campaignId: saleData.campaignId, // 연관 캠페인 (있는 경우)
    memo: saleData.memo
  };
  
  // 2. 데이터베이스 저장
  const savedSale = await api.post('/api/sales', calculatedData);
  
  // 3. 실시간 통계 업데이트 트리거
  await updateSalesStatistics();
  
  // 4. 자동 문서 생성 옵션
  if (systemSettings.autoGenerateDocuments) {
    await generateSalesDocuments(savedSale);
  }
  
  return savedSale;
};

// 인센티브 계산 함수
function calculateIncentiveAmount(saleData, employee) {
  const marginAmount = (saleData.actualSellingPrice - saleData.actualCostPrice) * saleData.quantity;
  const incentiveRate = employee.incentiveRate || 0;
  return Math.round(marginAmount * (incentiveRate / 100));
}
```

### 2. 매출 승인 워크플로우
```javascript
// 관리자 매출 승인/거절 프로세스
const approveSale = async (saleId, approvalData) => {
  const sale = await getSaleById(saleId);
  
  // 승인 시 처리
  if (approvalData.status === '승인') {
    // 1. 매출 상태 업데이트
    await updateSaleStatus(saleId, {
      status: '승인',
      approvedBy: loggedInUser.id,
      approvedAt: new Date(),
      reviewComment: approvalData.reviewComment
    });
    
    // 2. 원장 데이터 반영 (실시간)
    await updateLedgerData(sale);
    
    // 3. 인센티브 계산 대상에 추가
    await addToIncentiveCalculation(sale);
    
    // 4. 연관 캠페인 수익 업데이트
    if (sale.campaignId) {
      await updateCampaignFinancialSummary(sale.campaignId);
    }
    
    // 5. 구매요청 연동 (필요 시)
    if (sale.campaignId && sale.status === '승인') {
      // 승인된 매출에 대해 구매요청 생성 가능
      await enablePurchaseRequestCreation(sale);
    }
  }
  
  // 거절 시 처리
  if (approvalData.status === '거절') {
    await updateSaleStatus(saleId, {
      status: '거절',
      rejectedBy: loggedInUser.id,
      rejectedAt: new Date(),
      rejectReason: approvalData.rejectReason,
      reviewComment: approvalData.reviewComment
    });
  }
};
```

---

## 📚 원장 시스템 (실시간 재무 데이터 관리)

### 1. 통합 원장 데이터 구조
```javascript
// 실시간 원장 계산 시스템
const calculateLedgerData = async (userId, userRole, filters = {}) => {
  // 1. 매출 데이터 집계 (Sales 테이블)
  const salesLedger = await calculateSalesLedger(userId, userRole, filters);
  
  // 2. 캠페인 매출 데이터 집계 (Campaigns 테이블)
  const campaignLedger = await calculateCampaignLedger(userId, userRole, filters);
  
  // 3. 구매요청/지출 데이터 집계 (PurchaseRequests 테이블)  
  const expenseLedger = await calculateExpenseLedger(userId, userRole, filters);
  
  // 4. 인센티브 데이터 집계 (MonthlyIncentives 테이블)
  const incentiveLedger = await calculateIncentiveLedger(userId, userRole, filters);
  
  // 5. 통합 원장 생성
  return {
    // === 수익 부문 ===
    revenue: {
      // 직접 매출 (Sales 테이블에서)
      directSales: {
        totalAmount: salesLedger.totalRevenue,
        totalMargin: salesLedger.totalMargin,
        count: salesLedger.totalSales,
        breakdown: salesLedger.categoryBreakdown
      },
      
      // 캠페인 매출 (Campaigns 재무 요약에서)
      campaignRevenue: {
        totalAmount: campaignLedger.totalRevenue,
        totalMargin: campaignLedger.totalProfit,
        count: campaignLedger.totalCampaigns,
        breakdown: campaignLedger.campaignBreakdown
      },
      
      // 전체 매출
      total: {
        amount: salesLedger.totalRevenue + campaignLedger.totalRevenue,
        margin: salesLedger.totalMargin + campaignLedger.totalProfit,
        marginRate: calculateOverallMarginRate(salesLedger, campaignLedger)
      }
    },
    
    // === 비용 부문 ===
    expenses: {
      // 직접 비용 (구매요청)
      directCosts: {
        totalAmount: expenseLedger.totalAmount,
        approvedAmount: expenseLedger.approvedAmount,
        pendingAmount: expenseLedger.pendingAmount,
        breakdown: expenseLedger.typeBreakdown
      },
      
      // 캠페인 원가
      campaignCosts: {
        totalAmount: campaignLedger.totalCost,
        breakdown: campaignLedger.costBreakdown
      },
      
      // 전체 비용
      total: {
        amount: expenseLedger.totalAmount + campaignLedger.totalCost
      }
    },
    
    // === 인센티브 부문 ===
    incentives: {
      totalAmount: incentiveLedger.totalAmount,
      paidAmount: incentiveLedger.paidAmount,
      pendingAmount: incentiveLedger.pendingAmount,
      breakdown: incentiveLedger.employeeBreakdown
    },
    
    // === 최종 손익 ===
    profitLoss: {
      grossProfit: (salesLedger.totalRevenue + campaignLedger.totalRevenue) - 
                   (expenseLedger.totalAmount + campaignLedger.totalCost),
      netProfit: (salesLedger.totalRevenue + campaignLedger.totalRevenue) - 
                (expenseLedger.totalAmount + campaignLedger.totalCost) - 
                incentiveLedger.totalAmount,
      profitMargin: calculateProfitMargin(salesLedger, campaignLedger, expenseLedger, incentiveLedger)
    }
  };
};
```

### 2. 매출 원장 세부 계산
```javascript
// Sales 테이블 기반 매출 원장 계산
const calculateSalesLedger = async (userId, userRole, filters) => {
  const whereClause = buildPermissionFilter(userId, userRole);
  const timeFilter = buildTimeFilter(filters);
  
  // 1. 기본 매출 통계
  const salesStats = await db.query(`
    SELECT 
      COUNT(*) as totalSales,
      COUNT(CASE WHEN status = '승인' THEN 1 END) as approvedSales,
      COUNT(CASE WHEN status = '정산완료' THEN 1 END) as completedSales,
      SUM(CASE WHEN status IN ('승인', '정산완료') THEN totalSales ELSE 0 END) as totalRevenue,
      SUM(CASE WHEN status IN ('승인', '정산완료') THEN 
        (actualSellingPrice - actualCostPrice) * quantity ELSE 0 END) as totalMargin,
      SUM(CASE WHEN status IN ('승인', '정산완료') THEN incentiveAmount ELSE 0 END) as totalIncentives
    FROM Sales 
    WHERE ${whereClause} AND ${timeFilter}
  `);
  
  // 2. 카테고리별 분석
  const categoryBreakdown = await db.query(`
    SELECT 
      p.category,
      COUNT(s.id) as salesCount,
      SUM(s.totalSales) as categoryRevenue,
      SUM((s.actualSellingPrice - s.actualCostPrice) * s.quantity) as categoryMargin,
      AVG(s.marginRate) as avgMarginRate
    FROM Sales s
    JOIN Products p ON s.productId = p.id
    WHERE s.status IN ('승인', '정산완료') 
      AND ${whereClause} AND ${timeFilter}
    GROUP BY p.category
    ORDER BY categoryRevenue DESC
  `);
  
  // 3. 월별 트렌드
  const monthlyTrend = await db.query(`
    SELECT 
      YEAR(saleDate) as year,
      MONTH(saleDate) as month,
      COUNT(*) as salesCount,
      SUM(totalSales) as monthlyRevenue,
      SUM((actualSellingPrice - actualCostPrice) * quantity) as monthlyMargin
    FROM Sales
    WHERE status IN ('승인', '정산완료')
      AND ${whereClause} AND ${timeFilter}
    GROUP BY YEAR(saleDate), MONTH(saleDate)
    ORDER BY year DESC, month DESC
  `);
  
  // 4. 담당자별 실적 (관리자용)
  let salesPersonPerformance = [];
  if (userRole === '슈퍼 어드민' || userRole === '대행사 어드민') {
    salesPersonPerformance = await db.query(`
      SELECT 
        u.name as salesPersonName,
        COUNT(s.id) as salesCount,
        SUM(s.totalSales) as totalRevenue,
        SUM((s.actualSellingPrice - s.actualCostPrice) * s.quantity) as totalMargin,
        SUM(s.incentiveAmount) as totalIncentiveEarned
      FROM Sales s
      JOIN Users u ON s.salesPersonId = u.id
      WHERE s.status IN ('승인', '정산완료')
        AND ${whereClause} AND ${timeFilter}
      GROUP BY s.salesPersonId, u.name
      ORDER BY totalRevenue DESC
    `);
  }
  
  return {
    ...salesStats[0],
    categoryBreakdown,
    monthlyTrend,
    salesPersonPerformance
  };
};
```

### 3. 캠페인 매출 원장 계산
```javascript
// Campaigns 기반 매출 원장 계산
const calculateCampaignLedger = async (userId, userRole, filters) => {
  const campaigns = await getCampaignsByPermission(userId, userRole, filters);
  
  let totalRevenue = 0;
  let totalCost = 0;
  let totalProfit = 0;
  const campaignBreakdown = [];
  
  // 각 캠페인의 financial-summary 집계
  for (const campaign of campaigns) {
    try {
      const financialSummary = await api.get(`/api/campaigns/${campaign.id}/financial-summary`);
      const summary = financialSummary.data;
      
      totalRevenue += summary.totalRevenue || 0;
      totalCost += summary.totalCost || 0;  
      totalProfit += summary.totalProfit || 0;
      
      // 캠페인별 상세 데이터
      campaignBreakdown.push({
        campaignId: campaign.id,
        campaignName: campaign.name,
        clientName: campaign.client,
        managerName: campaign.User?.name,
        revenue: summary.totalRevenue || 0,
        cost: summary.totalCost || 0,
        profit: summary.totalProfit || 0,
        profitMargin: summary.totalRevenue > 0 ? 
          ((summary.totalProfit / summary.totalRevenue) * 100).toFixed(2) : 0,
        status: getCampaignStatus(campaign),
        completionRate: calculateCompletionRate(campaign)
      });
      
    } catch (error) {
      console.error(`캠페인 ${campaign.id} 재무 데이터 로딩 실패:`, error);
    }
  }
  
  return {
    totalCampaigns: campaigns.length,
    totalRevenue,
    totalCost,
    totalProfit,
    avgProfitMargin: totalRevenue > 0 ? ((totalProfit / totalRevenue) * 100).toFixed(2) : 0,
    campaignBreakdown: campaignBreakdown.sort((a, b) => b.revenue - a.revenue)
  };
};
```

### 4. 지출 원장 계산
```javascript
// PurchaseRequests 기반 지출 원장 계산  
const calculateExpenseLedger = async (userId, userRole, filters) => {
  const whereClause = buildPermissionFilter(userId, userRole);
  const timeFilter = buildTimeFilter(filters);
  
  // 1. 지출 현황 통계
  const expenseStats = await db.query(`
    SELECT 
      COUNT(*) as totalRequests,
      COUNT(CASE WHEN status = '승인 대기' THEN 1 END) as pendingRequests,
      COUNT(CASE WHEN status = '승인됨' THEN 1 END) as approvedRequests,
      COUNT(CASE WHEN status = '구매 완료' THEN 1 END) as completedRequests,
      COUNT(CASE WHEN status = '정산 완료' THEN 1 END) as settledRequests,
      SUM(amount) as totalAmount,
      SUM(CASE WHEN status IN ('승인됨', '구매 완료', '정산 완료') THEN amount ELSE 0 END) as approvedAmount,
      SUM(CASE WHEN status = '승인 대기' THEN amount ELSE 0 END) as pendingAmount
    FROM PurchaseRequests
    WHERE ${whereClause} AND ${timeFilter}
  `);
  
  // 2. 리소스 타입별 분석
  const typeBreakdown = await db.query(`
    SELECT 
      resourceType,
      COUNT(*) as requestCount,
      SUM(amount) as typeTotal,
      AVG(amount) as avgAmount,
      SUM(CASE WHEN status IN ('승인됨', '구매 완료', '정산 완료') THEN amount ELSE 0 END) as approvedTotal
    FROM PurchaseRequests
    WHERE ${whereClause} AND ${timeFilter}
    GROUP BY resourceType
    ORDER BY typeTotal DESC
  `);
  
  // 3. 캠페인별 지출 분석
  const campaignExpenses = await db.query(`
    SELECT 
      c.name as campaignName,
      c.client as clientName,
      COUNT(pr.id) as requestCount,
      SUM(pr.amount) as totalExpense,
      SUM(CASE WHEN pr.status IN ('승인됨', '구매 완료', '정산 완료') THEN pr.amount ELSE 0 END) as approvedExpense
    FROM PurchaseRequests pr
    JOIN Campaigns c ON pr.campaignId = c.id
    WHERE pr.campaignId IS NOT NULL 
      AND ${whereClause} AND ${timeFilter}
    GROUP BY pr.campaignId, c.name, c.client
    ORDER BY totalExpense DESC
  `);
  
  // 4. 월별 지출 트렌드
  const monthlyExpenseTrend = await db.query(`
    SELECT 
      YEAR(createdAt) as year,
      MONTH(createdAt) as month,
      COUNT(*) as requestCount,
      SUM(amount) as monthlyTotal,
      SUM(CASE WHEN status IN ('승인됨', '구매 완료', '정산 완료') THEN amount ELSE 0 END) as monthlyApproved
    FROM PurchaseRequests
    WHERE ${whereClause} AND ${timeFilter}
    GROUP BY YEAR(createdAt), MONTH(createdAt)
    ORDER BY year DESC, month DESC
  `);
  
  return {
    ...expenseStats[0],
    typeBreakdown,
    campaignExpenses,
    monthlyExpenseTrend
  };
};
```

---

## 💎 인센티브 계산 및 정산 시스템

### 1. 실시간 인센티브 계산
```javascript
// 직원별 실시간 인센티브 계산
const calculateRealTimeIncentive = async (employeeId, year, month) => {
  const employee = await getUserById(employeeId);
  if (!employee.incentiveRate || employee.incentiveRate <= 0) {
    return { totalIncentive: 0, breakdown: [] };
  }
  
  let totalIncentive = 0;
  const breakdown = [];
  
  // 1. Sales 테이블에서 직원이 등록한 승인된 매출
  const salesIncentive = await db.query(`
    SELECT 
      s.id,
      s.saleNumber,
      s.clientName,
      s.totalSales,
      (s.actualSellingPrice - s.actualCostPrice) * s.quantity as margin,
      s.incentiveAmount
    FROM Sales s
    WHERE s.salesPersonId = ? 
      AND s.status IN ('승인', '정산완료')
      AND YEAR(s.saleDate) = ? 
      AND MONTH(s.saleDate) = ?
  `, [employeeId, year, month]);
  
  salesIncentive.forEach(sale => {
    totalIncentive += sale.incentiveAmount;
    breakdown.push({
      type: 'direct_sale',
      source: `매출 ${sale.saleNumber}`,
      client: sale.clientName,
      revenue: sale.totalSales,
      margin: sale.margin,
      incentiveAmount: sale.incentiveAmount,
      incentiveRate: employee.incentiveRate
    });
  });
  
  // 2. 담당 캠페인에서 발생한 수익 기반 인센티브
  const managedCampaigns = await db.query(`
    SELECT id, name, client
    FROM Campaigns 
    WHERE managerId = ?
      AND YEAR(createdAt) <= ? 
      AND (YEAR(updatedAt) >= ? OR updatedAt IS NULL)
  `, [employeeId, year, year]);
  
  for (const campaign of managedCampaigns) {
    try {
      const financialSummary = await getCampaignFinancialSummary(campaign.id, { year, month });
      const campaignProfit = financialSummary.totalProfit || 0;
      
      if (campaignProfit > 0) {
        const campaignIncentive = Math.round(campaignProfit * (employee.incentiveRate / 100));
        totalIncentive += campaignIncentive;
        
        breakdown.push({
          type: 'campaign_management',
          source: `캠페인 ${campaign.name}`,
          client: campaign.client,
          revenue: financialSummary.totalRevenue || 0,
          margin: campaignProfit,
          incentiveAmount: campaignIncentive,
          incentiveRate: employee.incentiveRate
        });
      }
    } catch (error) {
      console.error(`캠페인 ${campaign.id} 인센티브 계산 실패:`, error);
    }
  }
  
  return {
    employeeId,
    employeeName: employee.name,
    incentiveRate: employee.incentiveRate,
    year,
    month,
    totalIncentive: Math.round(totalIncentive),
    breakdown
  };
};
```

### 2. 월말 인센티브 자동 정산
```javascript
// 월말 자동 인센티브 계산 및 정산 프로세스
const monthlyIncentiveSettlement = async (year, month) => {
  const results = [];
  
  // 1. 인센티브 대상 직원 조회
  const employees = await db.query(`
    SELECT id, name, incentiveRate, company
    FROM Users 
    WHERE role IN ('직원', '대행사 어드민') 
      AND incentiveRate > 0
      AND isActive = true
  `);
  
  for (const employee of employees) {
    try {
      // 2. 기존 정산 데이터 확인
      const existingSettlement = await db.query(`
        SELECT id FROM MonthlyIncentives 
        WHERE employeeId = ? AND year = ? AND month = ?
      `, [employee.id, year, month]);
      
      if (existingSettlement.length > 0) {
        results.push({
          employeeId: employee.id,
          status: 'skipped',
          message: '이미 정산된 데이터가 존재합니다.'
        });
        continue;
      }
      
      // 3. 실시간 인센티브 계산
      const incentiveData = await calculateRealTimeIncentive(employee.id, year, month);
      
      if (incentiveData.totalIncentive <= 0) {
        results.push({
          employeeId: employee.id,
          status: 'skipped',
          message: '인센티브 대상 실적이 없습니다.'
        });
        continue;
      }
      
      // 4. 정산 데이터 생성
      const settlementData = {
        employeeId: employee.id,
        year,
        month,
        totalSales: incentiveData.breakdown.reduce((sum, item) => sum + item.revenue, 0),
        totalMargin: incentiveData.breakdown.reduce((sum, item) => sum + item.margin, 0),
        incentiveRate: employee.incentiveRate,
        incentiveAmount: incentiveData.totalIncentive,
        adjustmentAmount: 0, // 수동 조정 금액
        finalAmount: incentiveData.totalIncentive,
        status: '검토대기',
        calculationDetails: JSON.stringify(incentiveData.breakdown),
        calculatedAt: new Date(),
        calculatorId: getCurrentUserId()
      };
      
      const savedSettlement = await db.query(`
        INSERT INTO MonthlyIncentives 
        (employeeId, year, month, totalSales, totalMargin, incentiveRate, 
         incentiveAmount, adjustmentAmount, finalAmount, status, calculationDetails, 
         calculatedAt, calculatorId)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `, Object.values(settlementData));
      
      results.push({
        employeeId: employee.id,
        employeeName: employee.name,
        status: 'created',
        incentiveAmount: incentiveData.totalIncentive,
        data: settlementData
      });
      
    } catch (error) {
      results.push({
        employeeId: employee.id,
        status: 'error',
        message: error.message
      });
    }
  }
  
  return {
    year,
    month,
    processedCount: results.length,
    createdCount: results.filter(r => r.status === 'created').length,
    skippedCount: results.filter(r => r.status === 'skipped').length,
    errorCount: results.filter(r => r.status === 'error').length,
    results
  };
};
```

---

## 📊 대시보드 실시간 원장 데이터 표시

### 1. 관리자용 종합 재무 대시보드
```javascript
// 실시간 재무 현황 계산 (대시보드용)
const getDashboardFinancialOverview = async (userId, userRole) => {
  // 1. 모든 원장 데이터 통합 계산
  const ledgerData = await calculateLedgerData(userId, userRole);
  
  // 2. 실시간 지표 계산
  const financialKPIs = {
    // === 매출 지표 ===
    revenue: {
      total: ledgerData.revenue.total.amount,
      salesRevenue: ledgerData.revenue.directSales.totalAmount,      // Sales 테이블
      campaignRevenue: ledgerData.revenue.campaignRevenue.totalAmount, // Campaigns 수익
      growthRate: await calculateRevenueGrowthRate(userId, userRole),
      monthlyTrend: await getMonthlyRevenueTrend(userId, userRole)
    },
    
    // === 비용 지표 ===  
    expenses: {
      total: ledgerData.expenses.total.amount,
      directCosts: ledgerData.expenses.directCosts.totalAmount,      // 구매요청
      campaignCosts: ledgerData.expenses.campaignCosts.totalAmount,  // 캠페인 원가
      pendingApprovals: ledgerData.expenses.directCosts.pendingAmount
    },
    
    // === 수익성 지표 ===
    profitability: {
      grossProfit: ledgerData.profitLoss.grossProfit,
      grossMargin: (ledgerData.profitLoss.grossProfit / ledgerData.revenue.total.amount * 100).toFixed(2),
      netProfit: ledgerData.profitLoss.netProfit,
      netMargin: (ledgerData.profitLoss.netProfit / ledgerData.revenue.total.amount * 100).toFixed(2),
      
      // 인센티브 전후 비교
      profitBeforeIncentives: ledgerData.profitLoss.grossProfit,
      profitAfterIncentives: ledgerData.profitLoss.netProfit,
      incentiveImpact: ledgerData.incentives.totalAmount
    },
    
    // === 인센티브 지표 ===
    incentives: {
      totalAmount: ledgerData.incentives.totalAmount,
      paidAmount: ledgerData.incentives.paidAmount,
      pendingAmount: ledgerData.incentives.pendingAmount,
      asPercentOfRevenue: (ledgerData.incentives.totalAmount / ledgerData.revenue.total.amount * 100).toFixed(2),
      asPercentOfProfit: (ledgerData.incentives.totalAmount / ledgerData.profitLoss.grossProfit * 100).toFixed(2)
    },
    
    // === 경고 및 알림 ===
    alerts: {
      // 인센티브가 순이익을 초과하는 경우
      incentiveExceedsProfit: ledgerData.incentives.totalAmount > ledgerData.profitLoss.grossProfit,
      
      // 미승인 구매요청 금액이 큰 경우  
      largePendingExpenses: ledgerData.expenses.directCosts.pendingAmount > 1000000,
      
      // 마진율이 낮은 경우
      lowMargin: parseFloat(ledgerData.profitLoss.profitMargin) < 10,
      
      // 미발행 계산서가 많은 경우
      pendingInvoices: await countPendingInvoices(userId, userRole)
    }
  };
  
  return financialKPIs;
};
```

### 2. 직원용 개인 실적 대시보드
```javascript
// 직원 개인 실적 및 인센티브 현황
const getEmployeeDashboard = async (employeeId) => {
  const employee = await getUserById(employeeId);
  const currentMonth = new Date();
  const year = currentMonth.getFullYear();
  const month = currentMonth.getMonth() + 1;
  
  // 1. 이번달 개인 실적
  const monthlyPerformance = {
    // 직접 매출
    directSales: await db.query(`
      SELECT 
        COUNT(*) as salesCount,
        SUM(totalSales) as totalRevenue,
        SUM((actualSellingPrice - actualCostPrice) * quantity) as totalMargin,
        SUM(incentiveAmount) as incentiveFromSales
      FROM Sales 
      WHERE salesPersonId = ? 
        AND YEAR(saleDate) = ? 
        AND MONTH(saleDate) = ?
        AND status IN ('승인', '정산완료')
    `, [employeeId, year, month]),
    
    // 담당 캠페인 실적
    campaignPerformance: await calculateEmployeeCampaignPerformance(employeeId, year, month),
    
    // 개인 KPI
    kpis: {
      conversionRate: await calculateSalesConversionRate(employeeId, year, month),
      avgDealSize: await calculateAvgDealSize(employeeId, year, month),
      clientSatisfaction: await getClientSatisfactionScore(employeeId)
    }
  };
  
  // 2. 인센티브 현황
  const incentiveStatus = {
    // 이번달 예상 인센티브 (실시간)
    thisMonth: await calculateRealTimeIncentive(employeeId, year, month),
    
    // 지난 3개월 인센티브 내역
    recentHistory: await getIncentiveHistory(employeeId, 3),
    
    // 연간 누적
    yearToDate: await getYearToDateIncentive(employeeId, year)
  };
  
  // 3. 업무 현황
  const workStatus = {
    // 담당 캠페인 현황
    campaigns: await db.query(`
      SELECT 
        COUNT(*) as totalCampaigns,
        COUNT(CASE WHEN invoiceIssued = false THEN 1 END) as pendingInvoices,
        COUNT(CASE WHEN paymentCompleted = false THEN 1 END) as pendingPayments
      FROM Campaigns 
      WHERE managerId = ?
    `, [employeeId]),
    
    // 미완료 작업
    pendingTasks: await getPendingTasksByEmployee(employeeId),
    
    // 클라이언트 관리 현황
    clientManagement: await getClientManagementStats(employeeId)
  };
  
  return {
    employee: {
      id: employee.id,
      name: employee.name,
      incentiveRate: employee.incentiveRate
    },
    monthlyPerformance,
    incentiveStatus,
    workStatus,
    // 목표 대비 진행률 (설정된 경우)
    goalProgress: await calculateGoalProgress(employeeId, year, month)
  };
};
```

---

## 🔄 자동 정산 및 마감 프로세스

### 1. 월말 자동 마감 프로세스
```javascript
// 월말 자동 마감 시스템
const monthlyClosingProcess = async (year, month) => {
  const closingResults = {
    startTime: new Date(),
    processes: [],
    summary: {},
    errors: []
  };
  
  try {
    // 1. 매출 데이터 마감
    console.log('매출 데이터 마감 시작...');
    const salesClosure = await closeSalesData(year, month);
    closingResults.processes.push({
      name: 'sales_closure',
      status: 'completed',
      data: salesClosure
    });
    
    // 2. 구매요청 데이터 마감
    console.log('구매요청 데이터 마감 시작...');
    const purchaseClosure = await closePurchaseData(year, month);
    closingResults.processes.push({
      name: 'purchase_closure', 
      status: 'completed',
      data: purchaseClosure
    });
    
    // 3. 인센티브 자동 계산 및 정산
    console.log('인센티브 정산 시작...');
    const incentiveSettlement = await monthlyIncentiveSettlement(year, month);
    closingResults.processes.push({
      name: 'incentive_settlement',
      status: 'completed', 
      data: incentiveSettlement
    });
    
    // 4. 캠페인 재무 요약 업데이트
    console.log('캠페인 재무 요약 업데이트 시작...');
    const campaignUpdate = await updateAllCampaignFinancialSummaries(year, month);
    closingResults.processes.push({
      name: 'campaign_financial_update',
      status: 'completed',
      data: campaignUpdate  
    });
    
    // 5. 월간 재무 리포트 생성
    console.log('월간 재무 리포트 생성 시작...');
    const monthlyReport = await generateMonthlyFinancialReport(year, month);
    closingResults.processes.push({
      name: 'monthly_report_generation',
      status: 'completed',
      data: monthlyReport
    });
    
    // 6. 시스템 백업
    console.log('데이터 백업 시작...');
    const backup = await createMonthlyDataBackup(year, month);
    closingResults.processes.push({
      name: 'data_backup',
      status: 'completed',
      data: backup
    });
    
    // 7. 마감 요약 정보 생성
    closingResults.summary = {
      period: `${year}-${month.toString().padStart(2, '0')}`,
      totalRevenue: salesClosure.totalRevenue + (campaignUpdate.totalRevenue || 0),
      totalExpenses: purchaseClosure.totalExpenses + (campaignUpdate.totalCosts || 0),
      totalIncentives: incentiveSettlement.results.reduce((sum, r) => 
        sum + (r.incentiveAmount || 0), 0),
      netProfit: null, // 계산됨
      employeesProcessed: incentiveSettlement.createdCount,
      reportsGenerated: 1
    };
    
    closingResults.summary.netProfit = 
      closingResults.summary.totalRevenue - 
      closingResults.summary.totalExpenses - 
      closingResults.summary.totalIncentives;
    
    closingResults.endTime = new Date();
    closingResults.duration = closingResults.endTime - closingResults.startTime;
    
    // 8. 마감 완료 알림 발송
    await sendClosingCompletionNotification(closingResults);
    
    console.log('월말 마감 프로세스 완료:', closingResults);
    return closingResults;
    
  } catch (error) {
    closingResults.errors.push({
      process: 'monthly_closing',
      error: error.message,
      timestamp: new Date()
    });
    
    // 에러 발생 시 롤백 (필요한 경우)
    await handleClosingError(closingResults, error);
    throw error;
  }
};
```

### 2. 데이터 정합성 검증
```javascript
// 원장 데이터 정합성 검증 시스템
const validateLedgerConsistency = async (year, month) => {
  const validationResults = {
    isValid: true,
    errors: [],
    warnings: [],
    summary: {}
  };
  
  try {
    // 1. 매출 데이터 검증
    const salesValidation = await validateSalesData(year, month);
    if (!salesValidation.isValid) {
      validationResults.isValid = false;
      validationResults.errors.push(...salesValidation.errors);
    }
    validationResults.warnings.push(...salesValidation.warnings);
    
    // 2. 인센티브 계산 검증
    const incentiveValidation = await validateIncentiveCalculations(year, month);
    if (!incentiveValidation.isValid) {
      validationResults.isValid = false;
      validationResults.errors.push(...incentiveValidation.errors);
    }
    
    // 3. 재무 데이터 일치성 검증
    const financialValidation = await validateFinancialConsistency(year, month);
    if (!financialValidation.isValid) {
      validationResults.isValid = false; 
      validationResults.errors.push(...financialValidation.errors);
    }
    
    // 4. 캠페인-매출 연동 검증
    const campaignSalesValidation = await validateCampaignSalesLinking(year, month);
    if (!campaignSalesValidation.isValid) {
      validationResults.warnings.push(...campaignSalesValidation.warnings);
    }
    
    validationResults.summary = {
      totalSalesRecords: salesValidation.recordCount,
      totalIncentiveRecords: incentiveValidation.recordCount,
      dataConsistencyScore: calculateConsistencyScore(validationResults),
      lastValidated: new Date()
    };
    
  } catch (error) {
    validationResults.isValid = false;
    validationResults.errors.push({
      type: 'validation_error',
      message: error.message,
      timestamp: new Date()
    });
  }
  
  return validationResults;
};
```

---

## 📈 비즈니스 인텔리전스 및 분석

### 1. 수익성 분석 대시보드
```javascript
// 수익성 분석 시스템
const generateProfitabilityAnalysis = async (userId, userRole, period = 'month') => {
  const analysis = {
    overview: {},
    trends: {},
    breakdown: {},
    insights: []
  };
  
  // 1. 전체 수익성 개요
  analysis.overview = {
    revenue: await getTotalRevenue(userId, userRole, period),
    costs: await getTotalCosts(userId, userRole, period),
    grossProfit: null, // 계산됨
    incentives: await getTotalIncentives(userId, userRole, period),
    netProfit: null,   // 계산됨
    margins: {
      gross: null,     // 계산됨  
      net: null        // 계산됨
    }
  };
  
  analysis.overview.grossProfit = analysis.overview.revenue - analysis.overview.costs;
  analysis.overview.netProfit = analysis.overview.grossProfit - analysis.overview.incentives;
  analysis.overview.margins.gross = (analysis.overview.grossProfit / analysis.overview.revenue * 100).toFixed(2);
  analysis.overview.margins.net = (analysis.overview.netProfit / analysis.overview.revenue * 100).toFixed(2);
  
  // 2. 수익성 트렌드 분석
  analysis.trends = {
    revenue: await getRevenueTrend(userId, userRole, period, 12), // 12개월
    profit: await getProfitTrend(userId, userRole, period, 12),
    margin: await getMarginTrend(userId, userRole, period, 12)
  };
  
  // 3. 세부 분석
  analysis.breakdown = {
    // 클라이언트별 수익성
    byClient: await getClientProfitability(userId, userRole, period),
    
    // 상품/서비스별 수익성
    byProduct: await getProductProfitability(userId, userRole, period),
    
    // 직원별 수익 기여도
    byEmployee: userRole !== '직원' ? 
      await getEmployeeProfitContribution(userId, userRole, period) : null,
    
    // 캠페인별 수익성
    byCampaign: await getCampaignProfitability(userId, userRole, period)
  };
  
  // 4. AI 기반 인사이트 생성
  analysis.insights = await generateBusinessInsights(analysis);
  
  return analysis;
};
```

### 2. 예측 분석 시스템
```javascript
// 매출 및 수익 예측 시스템
const generateFinancialForecast = async (userId, userRole, forecastMonths = 6) => {
  // 과거 데이터 수집 (최근 24개월)
  const historicalData = await getHistoricalFinancialData(userId, userRole, 24);
  
  const forecast = {
    period: `${forecastMonths}개월 예측`,
    methodology: 'time_series_analysis_with_seasonality',
    confidence: 0.85,
    predictions: []
  };
  
  // 시계열 분석을 통한 예측
  for (let i = 1; i <= forecastMonths; i++) {
    const targetDate = new Date();
    targetDate.setMonth(targetDate.getMonth() + i);
    
    const prediction = {
      year: targetDate.getFullYear(),
      month: targetDate.getMonth() + 1,
      revenue: await predictRevenue(historicalData, targetDate),
      costs: await predictCosts(historicalData, targetDate),
      profit: null, // 계산됨
      confidence: {
        revenue: calculatePredictionConfidence(historicalData.revenue, targetDate),
        costs: calculatePredictionConfidence(historicalData.costs, targetDate)
      }
    };
    
    prediction.profit = prediction.revenue - prediction.costs;
    forecast.predictions.push(prediction);
  }
  
  // 예측 정확도 향상을 위한 요소 고려
  forecast.factors = {
    seasonality: detectSeasonalityPattern(historicalData),
    trends: identifyTrends(historicalData),
    externalFactors: await getExternalFactors(), // 경제 지표, 시장 동향 등
    businessEvents: await getPlannedBusinessEvents() // 예정된 캠페인, 계약 등
  };
  
  return forecast;
};
```

이제 **영업직이 올린 데이터가 어떻게 원장으로 정리되고 정산되는지**의 전체 비즈니스 로직이 완벽히 포함되었습니다! 🎯

**핵심 흐름:**
1. **영업직 매출 등록** → 자동 마진/인센티브 계산
2. **관리자 승인** → 원장 데이터 즉시 반영  
3. **실시간 집계** → Sales + Campaigns + PurchaseRequests 통합
4. **월말 자동 정산** → 인센티브 계산 → 재무 리포트 생성
5. **대시보드 표시** → 실시간 KPI 및 수익성 분석

이제 완전한 비즈니스 로직이 문서화되었습니다! 📊